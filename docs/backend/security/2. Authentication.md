
### 2.1 Overview

The system uses a **dual-layer authentication approach**:

1. **Microsoft Entra ID (Azure AD) OAuth** - Primary authentication
    
2. **JWT Session Tokens** - Server-side session management
    

### 2.2 Azure AD Authentication

```directory
src/
├── app/
│   ├── authConfig.js (Configuration File)
│   └── api/
│       └── auth/
│           └── user-login/
│               └── route.js (Implementation File)
```

**Configuration Example** (`src/app/authConfig.js`):

```javascript
export const msalConfig = {
    auth: {
        clientId: process.env.NEXT_PUBLIC_CLIENT_ID,
        authority: process.env.NEXT_PUBLIC_AUTHORITY,
        redirectUri: process.env.NEXT_PUBLIC_REDIRECTURI,
        postLogoutRedirectUri: process.env.NEXT_PUBLIC_POSTLOGOUTREDIRECTURI,
        navigateToLoginRequestUrl: true,
    },
    cache: {
        cacheLocation: 'localStorage',
        storeAuthStateInCookie: true,
    },
    system: {
        loggerOptions: {
            loggerCallback: (level, message, containsPii) => {
                if (!containsPii) {
                    console.log(message);
                }
            },
        },
    },
};

export const loginRequest = {
    scopes: ['user.read'],
};
```

**Features**:

- Uses `@azure/msal-browser` and `@azure/msal-react` packages
    
- Configured with client ID and tenant authority
    
- Automatic token refresh
    
- Cache stored in localStorage (with storeAuthStateInCookie for IE11 compatibility)
    

**Flow**:

```
1. User initiates login
2. MSAL redirects to Azure AD
3. Azure AD authenticates user
4. User returns with auth code
5. Server creates JWT session token
6. Session stored in sessionStorage
```

### 2.3 JWT Session Management

```directory
src/
└── utils/
    └── auth/
        └── SimpleSessionManager.js
```

**Configuration**:

- **Algorithm**: HS256 (HMAC-SHA256)

- **Expiration**: 24 hours (default)

- **Secret**: 256-bit hexadecimal (from `SESSION_SECRET` env variable)

- **Issuer**: 'auth-service'

- **Audience**: 'app-users'


**Session Creation Example**:

```javascript
import SecureSessionManager from '@utils/auth/SimpleSessionManager';

// Create session from MSAL token
const { sessionToken, user_data } = await SecureSessionManager.CreateSession(msalToken);

// Returns:
// {
//   sessionToken: "eyJhbGciOi...",
//   user_data: {
//     email: "user@example.com",
//     name: "User Name",
//     tenantId: "tenant-id"
//   }
// }
```

**Session Validation Example**:

```javascript
// Validate JWT signature and expiration
const { session, success } = SecureSessionManager.ValidateSession(sessionToken);

if (success) {
    console.log('Session valid for:', session.email);
} else {
    console.log('Session expired or invalid');
}
```

**Methods**:

- `CreateSession(msalToken)` - Generate new JWT token with user claims

- `ValidateSession(sessionToken)` - Verify token signature and expiration

- `authenticateUser(req)` - Validate user from request headers against database

- `checkAuthorization(user, requiredRoles)` - Verify user has required roles
    

**Security Features**:

- Server-side signature verification on every request
    
- Token expiration enforced
    
- Issuer and audience validation
    
- User activation status checked on validation
    

### 2.4 Session Storage

**Frontend Storage**:

- User email and roles stored in `sessionStorage` (more secure than localStorage)
    
- Session cleared on browser close
    
- Session not persisted across browser restarts
    

**Validation**:

- Only email sent in request headers (`X-Session-User`)
    
- Server always validates against database
    
- Roles fetched fresh from database (never cached)
    
- Cannot spoof roles from frontend
